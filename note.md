# AHC014
## 2022.09.17
- 問題を読んで虚無解を提出、正の点数をとる

## 2022.09.26 Mon
- これまで放置していた（tweetdeck で観察だけしてた）
- 虚無解 +α くらいはやりたいなという気分になり、重い腰を上げて作業ディレクトリを作成
- 軽く考察
    - 格子点上に置かれた印
    - 印3つに1つ印を加えて長方形を作る
    - 得点
        - 印をたくさん加えると高得点が得られる
        - 中心から離れた格子点の印ほど高得点が得られる
    - 印をおく条件
        1. p_1~4_ をこの順番に結ぶと軸に平行、もしくは45度傾いた長方形となる。
        2. この長方形の外周上には p_1~4 以外に印の付いた格子点は存在しない。
        3. この長方形の外周は、既に方眼紙に描かれている長方形の外周と正の長さの共通部分を持たない(いくつかの点で交わることは許される)。
    - 問題情報
        - 入力の縦横の格子点の数は奇数で固定なので、「ど真ん中」に当たる格子点がある。
        - 「ど真ん中」の重みが 1点で、そこからマンハッタン距離で重みが定まる
    - 所感
        - 長方形を描くときに、既存の印を跨いではいけない、というのは、対応できそう
        - 長方形どうしが辺を共有してはいけないというのが、やっかいそう
        - 点数計算のロジックを使えればわかるかも？
            - lib.rs の compute_score あたり
- 少しだけ（のつもりが割とたくさん）実装
    - struct Input を、テストツールを参考に作成
    - struct Status を、テストツールを参考に作成
        - constructor を実装
        - check_move, apply_move は未実装
- vector でない単純な配列の初期値を指定する方法がわからなかった。
    - 色々バグらせたので、結局 vector で書くことにした。

## 2022.09.27 Tue
- Rust のスコア計算コードを、 C++ に移植している。
- check_move と apply_move を実装し終えた。
- 動作確認に移る。テストコードが書ければよいのだけれど、 C++ のことはわからん。
- 出力するところまで作った。
    - output ようオブジェクトを作って、からのまま出力
    - 虚無解と同じだけど、進んではいる。
- 昼休憩になったら提出して text で 0 を出力した時と同じになってるか確認する。

- 昼にコードを出して、しっかり text で 0 出力した時と同じ点数になっていることを確認。

- 業後に、虚無 +α を探す実装をやった
    - はじめ、前項視点を4重で探索するコードを書いたが、実行時間が長すぎ
    - 印のついた点を探索して、それを p2 とし、8方向に対して p1, p3 が 存在するか確認して、 p0 の位置を割り出し、それに対して check, apply を実行
- 実行時エラー（p0 を割り出したときに、番外に飛び出していた）などと戦いながら、なんとか、少し高い点数を獲得。
- 517位が大量にいて、これらが 0 を出力した時の点数。
    - それに対して、提出時点で 511位だった
    - [提出1](https://atcoder.jp/contests/ahc014/submissions/35198676)
    - Score: 14,342,777 (虚無解 + 2.1%)

    - 出力 0、つまり、1つも有効な手が見つからなかったというパターンが少なからず確認されたのが謎。
    
## 2022.09.28
- 近傍をスタックに詰めて、上から消化しながら印をつけたことで新たに発生した近傍を足して行こう！みたいなことを実装しようとしてたら、小さいケースで想定通りの動きをしておらず、バグを発見した。
- 出力 0 が出てて、どうも妙だなと思っていたのが解決した。
- バグを解消して昨日のコードのまま投げたら、少し点数上がってた。
- [提出2](https://atcoder.jp/contests/ahc014/submissions/35218633)
    - Score: 18,932,581 (虚無 + 34.8%) (トップの 24.8%)
    - 477位でかなり上がった。

## 2022.09.29
- 近傍をスタックに詰める関数はかけたので、近傍を効率よく実装できるように関数化したい。
- ある印から 8方向に印を探して、自身を p2 にして、直角方向に p1, p3 として、 p0 を割り出すパターン
    - 必要なのは、 status.has_point と、自身に当たる P 型の変数。point としよう。
    - 盤面のサイズも必要
    - 戻り値は、 vector<rect> で、 rect = vector<P>(4) という感じ。
    - ひとまずこちらだけ実装した。かなり点数上げられそう。
    - 業務の休憩中にやっているので、提出は我慢。
        - 18:00 になってすぐ提出。 → 提出3
            - なくなったらすぐやめるだけあって、実行時間はすぐに終わる。
- これと別に、自身を p1 として、行った先で左右に折れて p3 を探すというのもやりたい。
    - ちょっとヴィジュアライザで遊んでる感じ、こっちも実装したらさらに伸ばせそう。
    - これ実装した。と言っても、前項の関数に、新しくつけた印から8方向にまっすぐ進んでぶつかった既存の点を渡しただけなので、実装コストはそんなにない。
        -  → 提出4

- [提出3](https://atcoder.jp/contests/ahc014/submissions/35230786)
    - Score: 23,739,678 (虚無 + 69.0 %) (トップの 31.1%)
    - 463位に浮上。このへん過疎ってるな。
    - やはり、まだアルゴをやっている感じはあるな。

- [提出4](https://atcoder.jp/contests/ahc014/submissions/35231993)
    - Score: 30492374 (虚無の2倍超えた) (トップの 40.0%)
    - 389位に浮上。割と順位上がった。


- スタックに詰めているのを優先度付きキューとかにして、 rect[0] が中心から遠い順に並べて、その順番で追加していったら、多少得点は上がるかな？
    - vector<vector<P>> をに順序を導入しなければならない。
    - 比較関数作るか。
- 優先度付きキューに自作比較関数を組み込む方法がわからなかったので、vector にして毎回 sort するようにした。
    - 中心から遠い順ではなく、長方形が小さい順にした。
    - 具体的には、長辺と短辺のチェビシェフ距離の和が小さい方から順に適用していった
    - 同じ時は中心から遠い方から順に〜としたかったが、 N を運搬するのが面倒そうだったのでやめた。
        - N はスーパーグローバルにしてしまっても良いかもしれないな。
- [提出5](https://atcoder.jp/contests/ahc014/submissions/35234183)
    - Score: 32667079 (トップの 42.8%)
    - ちょっと改善。
    - 346位。勝手にライバル視しているかえで(@kaede20203)さんを追い抜いた！
    - 現時点で水色パフォでた！！

- 乱択の要素を入れるとしたら、多分近傍の処理順なんだよな
- あと、同じ点に印をつけるときに、どちらをの長方形を取るか


- めっちゃ楽しいし、もっと早く取り組んでおけばよかったなと思ったが、ここまで熱中できて、実装もそこそこいい感じにできているのは、間違いなく Rust でスコア計算用のコードを解読できているからだし、Rust はコンテスト期間の前半くらいで本格的に勉強して読めるようになったから、どちらにせよ最初から全速力というのはできてなかった。


## 2022.10.01
- 合奏と買い物から帰ってきて、ちょっと仮眠して、土壇場で新たな実装をやった。
- 乱択要素を取り入れ、何回も出発し直して最良のものを出力する
- スコア計算コードも実装した
    - 計算式の定数部分が多かった
- [提出](https://atcoder.jp/contests/ahc014/submissions/35268143)
    - Score: 36,912,617 (トップの 47.2%) 
    - 前回提出 + 13.0%
    - かえでさんに僅かに抜かれていたが、再び抜き返した。
    - 239位、めっちゃ上がった。

- 解説
    - 小さい長方形を選ぶ
    - 真ん中の方から埋めていく
    - 各点に対して8方向全てを使っていきたい
        - 辺の上には点を置かない
        - 反対の角に辺が生えてる点を優先
    - 焼きなまし
        - 一部の印と、その点を使って描かれた長方形の印を連鎖的に全て消す
        - rondom playout を適用して、さらに描き尽くす

- 伸び代
    - ランダムをもっと信用して良い
    - c++ の乱数をもっと早くから実装する